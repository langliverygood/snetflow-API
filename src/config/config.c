#include <stdio.h>#include <stdint.h>#include <stdlib.h>#include <string.h>#include <sys/socket.h>#include <netinet/in.h>#include <arpa/inet.h>#include <libconfig.h>#include <iostream>#include <string>#include <map>#include "config.h"using namespace std;static map<string, mysql_conf_s> top;static map<string, mysql_conf_s> trend;static map<string, mysql_conf_s> history;void read_cfg_file(const char *file){    int cnt, i;    char f[256];    const char *name, *table, *column, *condition;    mysql_conf_s conf;    config_t cfg;    config_setting_t *setting, *tmp;    if (!file || strlen(file) == 0)    {        sprintf(f, "%s", "/etc/snetflow-API/snetflow-API.cfg");    }    else    {        snprintf(f, sizeof(f) - 1, "%s", file);    }    /* 打开配置文件 */    config_init(&cfg);    if (!config_read_file(&cfg, f))    {        fprintf(stderr, "%s:%d - %s\n", config_error_file(&cfg), config_error_line(&cfg), config_error_text(&cfg));        config_destroy(&cfg);        exit(-1);    }    /* 读取配置文件top */    setting = config_lookup(&cfg, "top");    if (setting != NULL)    {        cnt = config_setting_length(setting);        for (i = 0; i < cnt; i++)        {            tmp = config_setting_get_elem(setting, i);            if (!(config_setting_lookup_string(tmp, "name", &name) && config_setting_lookup_string(tmp, "table", &table) && config_setting_lookup_string(tmp, "column", &column) && config_setting_lookup_string(tmp, "condition", &condition)))            {                fprintf(stderr, "Invalid key or value\n");                exit(-1);            }			strncpy(conf.name, name, sizeof(conf.name));			strncpy(conf.table, table, sizeof(conf.table));			strncpy(conf.column, column, sizeof(conf.column));			strncpy(conf.condition, condition, sizeof(conf.condition));			top[conf.name] = conf;        }    }    else    {        fprintf(stderr, "Can't find top\n");        exit(-1);    }	/* 读取配置文件trend */    setting = config_lookup(&cfg, "trend");    if (setting != NULL)    {        cnt = config_setting_length(setting);        for (i = 0; i < cnt; i++)        {            tmp = config_setting_get_elem(setting, i);            if (!(config_setting_lookup_string(tmp, "name", &name) && config_setting_lookup_string(tmp, "table", &table) && config_setting_lookup_string(tmp, "column", &column) && config_setting_lookup_string(tmp, "condition", &condition)))            {                fprintf(stderr, "Invalid key or value\n");                exit(-1);            }			strncpy(conf.name, name, sizeof(conf.name));			strncpy(conf.table, table, sizeof(conf.table));			strncpy(conf.column, column, sizeof(conf.column));			strncpy(conf.condition, condition, sizeof(conf.condition));			trend[conf.name] = conf;        }    }    else    {        fprintf(stderr, "Can't find trend\n");        exit(-1);    }	/* 读取配置文件history */    setting = config_lookup(&cfg, "history");    if (setting != NULL)    {        cnt = config_setting_length(setting);        for (i = 0; i < cnt; i++)        {            tmp = config_setting_get_elem(setting, i);            if (!(config_setting_lookup_string(tmp, "name", &name) && config_setting_lookup_string(tmp, "table", &table) && config_setting_lookup_string(tmp, "column", &column) && config_setting_lookup_string(tmp, "condition", &condition)))            {                fprintf(stderr, "Invalid key or value\n");                exit(-1);            }			strncpy(conf.name, name, sizeof(conf.name));			strncpy(conf.table, table, sizeof(conf.table));			strncpy(conf.column, column, sizeof(conf.column));			strncpy(conf.condition, condition, sizeof(conf.condition));			history[conf.name] = conf;        }    }    else    {        fprintf(stderr, "Can't find history\n");        exit(-1);    }	config_destroy(&cfg);	return;}mysql_conf_s *get_config(const char *key, int kind){	if(kind == TOP && top.find(key) != top.end())	{		return &(top[key]);	}	else if(kind == TREND && trend.find(key) != trend.end())	{		return &(trend[key]);	}	else if(kind == HISTORY && history.find(key) != history.end())	{		return &(history[key]);	}		return NULL;}